#!/bin/bash -eu
#
# Build and manipulate a Raspberry Pi image
#

function out()
{
	local rc=${?}

	trap - INT TERM EXIT HUP

	if [ -n "${MOUNTDEV}" ] && [ -n "${MOUNTPOINT}" ] ; then
		# Unmount any device that's still mounted
		umount_dev "${MOUNTDEV}" "${MOUNTPOINT}"
		rmdir "${MOUNTPOINT}"
	fi

	if [ "${rc}" -ne 0 ] ; then
		# Emit a message if the script failed
		pr_error "Script failed"
	fi

	exit "${rc}"
}

function dry_run_exit()
{
	if [ "${DRY_RUN}" -eq 1 ] ; then
		pr_info "Dry-run, exiting..."
		exit
	fi
}

function pr_info()
{
    echo -e "\033[33m${*}\033[0m"

}

function pr_debug()
{
    [ "${DEBUG}" -eq 0 ] || echo -e "\033[36m${*}\033[0m"

}

function pr_error()
{
    echo -e "\033[31mError: ${*}\033[0m" >&2
	exit 1

}

function align()
{
	local val=${1} align=${2}

	echo $(($((val / align + 1)) * align))
}

function probe_dev()
{
	local dev=${1}
	local nr start size ptype

	while IFS=' ' read -r nr start size ptype ; do
		echo "${nr} ${start} ${size} ${ptype#0x}"
	done < <(partx -g -o NR,START,SECTORS,TYPE "${dev}")
}

function partx_add_dev()
{
	local dev

	IFS=':' read -r -a dev <<< "${1}"

	# Add the specified partition and print the loop device /dev/loopX
	partx -v -a -n "${dev[1]}" "${dev[0]}" | \
		grep "partition #${dev[1]} added" | sed 's,:.*,,'
}

function partx_del_dev()
{
	local dev

	IFS=':' read -r -a dev <<< "${1}"

	# Delete the specified partition
	partx -v -d -n "${dev[1]}" "${dev[0]}"
}

function mount_dev()
{
	local dev mountpoint loopdev part

	pr_info "Mounting ${1}"

	IFS=':' read -r -a dev <<< "${1}"
	mountpoint=${2}

	if [ -f "${dev[0]}" ] ; then
		# It's an image file, so run partx -a (add)
		pr_info "Adding partition ${1}"
		loopdev=$(partx_add_dev "${1}")
		pr_debug "loopdev: ${loopdev}"
		part=${loopdev}p${dev[1]}
	else
		part=${dev[0]}${dev[1]}
	fi

	mount "${part}" "${mountpoint}"
}

function umount_dev()
{
	local dev mountpoint

	pr_info "Unmounting ${1}"

	IFS=':' read -r -a dev <<< "${1}"
	mountpoint=${2}

	umount "${mountpoint}" || umount -l "${mountpoint}"

	if [ -f "${dev[0]}" ] ; then
		pr_info "Deleting partition ${1}"
		# It's a image file, so run partx -d (delete)
		partx_del_dev "${1}"
	fi
}

function umount_dev_all()
{
	local dev=${1}
	local mountpoint

	if ! [ -b "${dev}" ] ; then
		# Not a block device, nothing to do
		return
	fi

	pr_info "Unmounting all partitions of ${dev}"

	# Unmount all partitions of the device
	while IFS= read -r mountpoint ; do
		if [ -n "${mountpoint}" ] && [ -d "${mountpoint}" ] ; then
			umount "${mountpoint}" || umount -l "${mountpoint}"
		fi
	done < <(lsblk -n -o MOUNTPOINT "${dev}")
}

function dd_dev()
{
	local src dst dd_opts src_part dst_part

	pr_info "Copying device/partition ${1} to ${2}"

	IFS=':' read -r -a src <<< "${1}"
	IFS=':' read -r -a dst <<< "${2}"

	src_part=()
	dst_part=()
	dd_opts=("if=${src[0]}" "of=${dst[0]}" "bs=512" "conv=notrunc")

	pr_debug "src: ${src[*]}"
	if [ "${#src[@]}" -eq 2 ] ; then
		# Source partition number specified, get the partition details
		IFS=' ' read -r -a src_part < <(probe_dev "${src[0]}" | \
											grep "^${src[1]} ")
		pr_debug "src_part: ${src_part[*]}"
		dd_opts+=("skip=${src_part[1]}" "count=${src_part[2]}")
	fi

	pr_debug "dst: ${dst[*]}"
	if [ "${#dst[@]}" -eq 2 ] ; then
		# Destination partition number specified, get the partition details
		IFS=' ' read -r -a dst_part < <(probe_dev "${dst[0]}" | \
											grep "^${dst[1]} ")
		pr_debug "dst_part: ${dst_part[*]}"
		dd_opts+=("seek=${dst_part[1]}")
	fi

	pr_debug "dd_opts: ${dd_opts[*]}"

	# Check that the destination partition is big enough
	if [ "${#src_part[@]}" -gt 1 ] && [ "${#dst_part[@]}" -gt 1 ] && \
		   [ "${src_part[2]}" -gt "${dst_part[2]}" ] ; then
		pr_error "Destination partition is too small"
	fi

	# Exit if this is a dry-run
	dry_run_exit

	# Unmount all partitions (just in case)
	umount_dev_all "${dst[0]}"

	# Copy the partition
	dd "${dd_opts[@]}"
}

function config_dev()
{
	local dev=${1}
	local script mountpoint

	# Unmount all partitions (just in case)
	umount_dev_all "${dev}"

	# Compile all u-boot scripts
	while IFS= read -r script ; do
		pr_info "Building u-boot script ${script}"
        mkimage -A arm -T script -C none -n 'u-boot script' -d "${script}" \
				"${script%.txt}"
	done < <(find boot/ -name '*.scr.txt')

	# Create a temporary mount point
	MOUNTPOINT=$(mktemp -d --tmpdir raspi-image-XXXXXX)
	pr_debug "MOUNTPOINT: ${MOUNTPOINT}"

	# Configure the boot partition (partition 1)
	MOUNTDEV=${dev}:1
	mount_dev "${MOUNTDEV}" "${MOUNTPOINT}"
	pr_info "Copying files to the boot partition ${MOUNTDEV}"

	rm -f "${MOUNTPOINT}"/uboot_*.env "${MOUNTPOINT}"/*.img
	cp boot/config.txt boot/boot.scr boot/uboot_*.bin "${MOUNTPOINT}"/

	umount_dev "${MOUNTDEV}" "${MOUNTPOINT}"

	# Configure the Raspbian boot partition (partition 5)
	MOUNTDEV=${dev}:5
	mount_dev "${MOUNTDEV}" "${MOUNTPOINT}"
	pr_info "Copying files to the Raspbian boot partition ${MOUNTDEV}"

	cp boot/raspbian/boot.scr "${MOUNTPOINT}"/

	umount_dev "${MOUNTDEV}" "${MOUNTPOINT}"

	# Fix up the Raspbian rootfs partition (partition 6)
	MOUNTDEV=${dev}:6
	mount_dev "${MOUNTDEV}" "${MOUNTPOINT}"
	pr_info "Fixing up the Raspbian rootfs partition ${MOUNTDEV}"

	# Make sure nobody can call init_resize.sh since it would mess up our
	# partition table
	if [ -e "${MOUNTPOINT}"/usr/lib/raspi-config/init_resize.sh ] ; then
		mv "${MOUNTPOINT}"/usr/lib/raspi-config/init_resize.sh \
		   "${MOUNTPOINT}"/usr/lib/raspi-config/init_resize.sh.bak
	fi

	# Fix the UUIDs of the boot and rootfs partitions
	sed -i 's,PARTUUID=[0-9a-f]*-01,PARTUUID=deadbeef-05,' \
		"${MOUNTPOINT}"/etc/fstab
	sed -i 's,PARTUUID=[0-9a-f]*-02,PARTUUID=deadbeef-06,' \
		"${MOUNTPOINT}"/etc/fstab

	umount_dev "${MOUNTDEV}" "${MOUNTPOINT}"

	# Cleanup
	rmdir "${MOUNTPOINT}" || true
	MOUNTDEV=
	MOUNTPOINT=
}

function init_dev()
{
	local dev=${1} image=${2}
	local dev_size img_parts img_part1 img_part2
	local part1_start part1_size part1_type part2_start part2_size part2_type
	local part5_start part5_size part5_type part6_start part6_size part6_type

	pr_info "Initializing device ${dev}"

	# Get the size of the device (in #sectors)
	dev_size=$(sfdisk -s "${dev}")
	[ -n "${dev_size}" ]
	dev_size=$((dev_size * 1024 / 512))
	pr_debug "dev_size: ${dev_size}"

	# Get the partition information from the image file
	readarray -t img_parts < <(probe_dev "${image}")
	IFS=' ' read -r -a img_part1 <<< "${img_parts[0]}"
	IFS=' ' read -r -a img_part2 <<< "${img_parts[1]}"
	pr_debug "img_part1: ${img_part1[*]}"
	pr_debug "img_part2: ${img_part2[*]}"

	# The (custom/multiboot) boot partition
	part1_start=2048
	part1_size=${img_part1[2]}
	part1_type=${img_part1[3]}
	pr_debug "part1: start ${part1_start}, size ${part1_size}," \
			 "type ${part1_type}"

	# The extended partition
	part2_start=$((part1_start + part1_size))
	part2_size=$((dev_size - part2_start))
	part2_type=5
	pr_debug "part2: start ${part2_start}, size ${part2_size}," \
			 "type ${part2_type}"

	# The Raspbian boot partition
	part5_start=$(align "${part2_start}" 2048)
	part5_size=${img_part1[2]}
	part5_type=${img_part1[3]}
	pr_debug "part5: start ${part5_start}, size ${part5_size}," \
			 "type ${part5_type}"

	# The Raspbian rootfs partition
	part6_start=$((part5_start + part5_size))
	part6_size=$((3 * 1024 * 1024 * 1024 / 512))  # 3GB fixed size
	part6_type=${img_part2[3]}
	pr_debug "part6: start ${part6_start}, size ${part6_size}," \
			 "type ${part6_type}"

	# Create the input file for sfdisk
	cat <<EOF >sfdisk.in
label: dos
label-id: 0xdeadbeef
device: ${dev}
unit: sectors

${dev}1 : start=${part1_start}, size=${part1_size}, type=${part1_type}, bootable
${dev}2 : start=${part2_start}, size=${part2_size}, type=${part2_type}
${dev}5 : start=${part5_start}, size=${part5_size}, type=${part5_type}
${dev}6 : start=${part6_start}, size=${part6_size}, type=${part6_type}
EOF

	# Exit if this is a dry-run
	if [ "${DRY_RUN}" -eq 1 ] ; then
		cat sfdisk.in
	fi
	dry_run_exit

	# Unmount all partitions (just in case)
	umount_dev_all "${dev}"

	# Wipe and partition the device
	pr_info "Partitioning device ${dev}"
	wipefs -a -f "${dev}"
	if [ "${DEBUG}" -eq 1 ] ; then
		sfdisk "${dev}" < sfdisk.in
	else
		sfdisk -q "${dev}" < sfdisk.in
		sfdisk -l "${dev}"
	fi

	# Re-read the modified partition table
	if [ -b "${dev}" ] ; then
		partx -u "${dev}"
	fi

	# Copy the partitions from the Raspbian image to the device
	dd_dev "${image}:1" "${dev}:1"
	dd_dev "${image}:1" "${dev}:5"
	dd_dev "${image}:2" "${dev}:6"
}

# -----------------------------------------------------------------------------
# Commands

function do_init()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	init_dev "${@}"
}

function do_config()
{
	if [ $# -ne 1 ] ; then
		usage
		exit 2
	fi

	config_dev "${@}"
}

function do_dd()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	dd_dev "${@}"
}

function usage()
{
	trap - EXIT INT TERM HUP

	cat <<EOF
Usage: raspi-image [-d] [-h] [r] COMMAND [OPTIONS]

Supported commands
  init DEVICE RASPBIAN_IMAGE
                 Initialize the device <DEVICE> using the Raspbian image
                 <RASPBIAN_IMAGE>.
  config DEVICE
                 Configure the already initialized device DEVICE.
  dd DEVICE1[:PARTITION1] DEVICE2[:PARTITION2]
                 Copy DEVICE1 to DEVICE2 using 'dd'. Operate on a partition
                 rather than a whole device if a PARTITIION number is
                 specified.

Positional arguments:
  -d, --debug    Enable debugging output.
  -h, --help     Show this help text and exit.
  -r, --dry-run  Dry run mode. If specified, no modifcations of a device/image
                 are made.
EOF
}

DEBUG=0
DRY_RUN=0
cmd=
cmd_opts=()

while [ $# -gt 0 ] ; do
	case "${1}" in
		-d|--debug)
			DEBUG=1
			;;
		-h|--help)
			usage
			exit
			;;
		-r|--dry-run)
			DRY_RUN=1
			;;
		-*)
			pr_error "Unexpected argument: ${1}"
			;;
		*)
			cmd=${1}
			shift
			cmd_opts=("${@}")
			break
	esac
	shift
done

case "${cmd}" in
	init|config|dd)
		true
		;;
	*)
		usage
		exit 2
		;;
esac

trap out EXIT INT TERM HUP

"do_${cmd}" "${cmd_opts[@]}"
