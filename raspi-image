#!/bin/bash -eu
#
# Build and manipulate a Raspberry Pi image
#

function out()
{
	local rc=${?}

	trap - INT TERM EXIT HUP

	if [ "${rc}" -ne 0 ] ; then
		pr_error "Script failed"
	fi

	exit "${rc}"
}

function dry_run_exit()
{
	if [ "${DRY_RUN}" -eq 1 ] ; then
		pr_info "Dry-run, exiting..."
		exit
	fi
}

function pr_info()
{
    echo -e "\033[33m${*}\033[0m"

}

function pr_debug()
{
    [ "${DEBUG}" -eq 0 ] || echo -e "\033[36m${*}\033[0m"

}

function pr_error()
{
    echo -e "\033[31mError: ${*}\033[0m" >&2
	exit 1

}

function align()
{
	local val=${1} align=${2}

	echo $(($((val / align + 1)) * align))
}

# TODO: Use partx -o START,END,.... instead of sfdisk
function probe_dev()
{
	local dev=${1}
	local line num start size ptype

	while IFS= read -r line ; do
		num=${line#${dev}}
		num=${num%% *}

		start=${line#* start=}
		start=${start%%, *}
		start=${start##* }

		size=${line#* size=}
		size=${size%%, *}
		size=${size##* }

		ptype=${line#* type=}
		ptype=${ptype%%, *}
		ptype=${ptype##* }

		echo "${num} ${start} ${size} ${ptype}"
	done < <(sfdisk -d "${dev}" | grep -P "^${dev}[0-9]+ ")
}

function umount_dev()
{
	local dev=${1}
	local tmp mountp

	if ! [ -b "${dev}" ] ; then
		# Not a block device, nothing to do
		return
	fi

	pr_info "Unmounting ${dev} partition(s)"

	# Unmount all partitions of the device
	# shellcheck disable=SC2034
	while IFS=' ' read -r tmp tmp tmp tmp tmp tmp mountp ; do
		if [ -n "${mountp}" ] && [ -d "${mountp}" ] ; then
			umount "${mountp}" || umount -l "${mountp}" || true
		fi
	done < <(lsblk -n -l "${dev}")
}

function dd_dev()
{
	local src dst dd_opts src_part dst_part

	pr_info "Copying device/partition ${1} to ${2}"

	IFS=':' read -r -a src <<< "${1}"
	IFS=':' read -r -a dst <<< "${2}"

	src_part=()
	dst_part=()
	dd_opts=("if=${src[0]}" "of=${dst[0]}" "bs=512" "conv=notrunc")

	pr_debug "src: ${src[*]}"
	if [ "${#src[@]}" -eq 2 ] ; then
		# Source partition number specified, get the partition details
		IFS=' ' read -r -a src_part < <(probe_dev "${src[0]}" | \
											grep "^${src[1]} ")
		pr_debug "src_part: ${src_part[*]}"
		dd_opts+=("skip=${src_part[1]}" "count=${src_part[2]}")
	fi

	pr_debug "dst: ${dst[*]}"
	if [ "${#dst[@]}" -eq 2 ] ; then
		# Destination partition number specified, get the partition details
		IFS=' ' read -r -a dst_part < <(probe_dev "${dst[0]}" | \
											grep "^${dst[1]} ")
		pr_debug "dst_part: ${dst_part[*]}"
		dd_opts+=("seek=${dst_part[1]}")
	fi

	pr_debug "dd_opts: ${dd_opts[*]}"

	# Check that the destination partition is big enough
	if [ "${#src_part[@]}" -gt 1 ] && [ "${#dst_part[@]}" -gt 1 ] && \
		   [ "${src_part[2]}" -gt "${dst_part[2]}" ] ; then
		pr_error "Destination partition is too small"
	fi

	# Exit if this is a dry-run
	dry_run_exit

	# Unmount the partitions (just in case)
	umount_dev "${dst[0]}"

	# Copy the partition
	dd "${dd_opts[@]}"
}

function init_dev()
{
	local dev=${1} image=${2}
	local dev_size img_parts img_part1 img_part2
	local part1_start part1_size part1_type part2_start part2_size part2_type
	local part5_start part5_size part5_type part6_start part6_size part6_type

	pr_info "Initializing device ${dev}"

	# Get the size of the device (in #sectors)
	dev_size=$(sfdisk -s "${dev}")
	[ -n "${dev_size}" ]
	dev_size=$((dev_size * 1024 / 512))
	pr_debug "dev_size: ${dev_size}"

	# Get the partition information from the image file
	readarray -t img_parts < <(probe_dev "${image}")
	IFS=' ' read -r -a img_part1 <<< "${img_parts[0]}"
	IFS=' ' read -r -a img_part2 <<< "${img_parts[1]}"
	pr_debug "img_part1: ${img_part1[*]}"
	pr_debug "img_part2: ${img_part2[*]}"

	# The (custom/multiboot) boot partition
	part1_start=2048
	part1_size=${img_part1[2]}
	part1_type=${img_part1[3]}
	pr_debug "part1: start ${part1_start}, size ${part1_size}," \
			 "type ${part1_type}"

	# The extended partition
	part2_start=$((part1_start + part1_size))
	part2_size=$((dev_size - part2_start))
	part2_type=5
	pr_debug "part2: start ${part2_start}, size ${part2_size}," \
			 "type ${part2_type}"

	# The raspbian boot partition
	part5_start=$(align "${part2_start}" 2048)
	part5_size=${img_part1[2]}
	part5_type=${img_part1[3]}
	pr_debug "part5: start ${part5_start}, size ${part5_size}," \
			 "type ${part5_type}"

	# The raspbian rootfs partition
	part6_start=$((part5_start + part5_size))
	part6_size=$((3 * 1024 * 1024 * 1024 / 512))  # 3GB fixed size
	part6_type=${img_part2[3]}
	pr_debug "part6: start ${part6_start}, size ${part6_size}," \
			 "type ${part6_type}"

	# Create the input file for sfdisk
	cat <<EOF >sfdisk.in
label: dos
label-id: 0xdeadbeef
device: ${dev}
unit: sectors

${dev}1 : start=${part1_start}, size=${part1_size}, type=${part1_type}, bootable
${dev}2 : start=${part2_start}, size=${part2_size}, type=${part2_type}
${dev}5 : start=${part5_start}, size=${part5_size}, type=${part5_type}
${dev}6 : start=${part6_start}, size=${part6_size}, type=${part6_type}
EOF

	# Exit if this is a dry-run
	if [ "${DRY_RUN}" -eq 1 ] ; then
		cat sfdisk.in
	fi
	dry_run_exit

	# Unmount the partitions (just in case)
	umount_dev "${dev}"

	# Wipe and partition the device
	pr_info "Partitioning device ${dev}"
	wipefs -a -f "${dev}"
	if [ "${DEBUG}" -eq 1 ] ; then
		sfdisk "${dev}" < sfdisk.in
	else
		sfdisk -q "${dev}" < sfdisk.in
		sfdisk -l "${dev}"
	fi

	# Re-read the modified partition table
	if [ -b "${dev}" ] ; then
		partx -u "${dev}"
	fi

	# Copy the partitions from the raspbian image to the device
	dd_dev "${image}:1" "${dev}:1"
	dd_dev "${image}:1" "${dev}:5"
	dd_dev "${image}:2" "${dev}:6"
}

# -----------------------------------------------------------------------------
# Commands

function do_init()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	init_dev "${@}"
}

function do_dd()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	dd_dev "${@}"
}

function usage()
{
	trap - EXIT INT TERM HUP

	cat <<EOF
Usage: raspi-image [-d] [-h] [r] COMMAND [OPTIONS]

Supported commands
  init DEVICE OS_IMAGE
                 Build a base image on device <DEVICE> using the image
                 <OS_IMAGE>.
  dd DEVICE1[:PARTITION1] DEVICE2[:PARTITION2]
                 Copy DEVICE1 to DEVICE2 using 'dd'. Operate on a partition
                 rather than a whole device if a PARTITIION number is
                 specified.

Positional arguments:
  -d, --debug    Enable debugging output.
  -h, --help     Show this help text and exit.
  -r, --dry-run  Dry run mode. If specified, no modifcations of a device/image
                 are made.
EOF
}

DEBUG=0
DRY_RUN=0
cmd=
cmd_opts=()

while [ $# -gt 0 ] ; do
	case "${1}" in
		-d|--debug)
			DEBUG=1
			;;
		-h|--help)
			usage
			exit
			;;
		-r|--dry-run)
			DRY_RUN=1
			;;
		-*)
			pr_error "Unexpected argument: ${1}"
			;;
		*)
			cmd=${1}
			shift
			cmd_opts=("${@}")
			break
	esac
	shift
done

case "${cmd}" in
	init|dd)
		true
		;;
	*)
		usage
		exit 2
		;;
esac

trap out EXIT INT TERM HUP

"do_${cmd}" "${cmd_opts[@]}"
