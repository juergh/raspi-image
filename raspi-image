#!/bin/bash -eu
#
# Build and manipulate a Raspberry Pi image
#

function out()
{
	local rc=${?}

	trap - INT TERM EXIT HUP

	# Clean up the mount and loop devices
	umount_dev
	losetup_detach

	if [ "${rc}" -ne 0 ] ; then
		# Emit a message if the script failed
		pr_error "Script failed"
	fi

	exit "${rc}"
}

function dry_run_exit()
{
	if [ "${DRY_RUN}" -eq 1 ] ; then
		pr_info "Dry-run, exiting..."
		exit
	fi
}

function pr_info()
{
    echo -e "\033[33m${*}\033[0m"

}

function pr_debug()
{
    [ "${DEBUG}" -eq 0 ] || echo -e "\033[36m${*}\033[0m"

}

function pr_error()
{
    echo -e "\033[31mError: ${*}\033[0m" >&2
	exit 1

}

function align()
{
	local val=${1} align=${2}

	echo $(($((val / align + 1)) * align))
}

function probe_dev()
{
	local dev=${1}
	local nr start size ptype

	while IFS=' ' read -r nr start size ptype ; do
		echo "${nr} ${start} ${size} ${ptype#0x}"
	done < <(partx -g -o NR,START,SECTORS,TYPE "${dev}")
}

function losetup_attach()
{
	local image=${1}

	pr_info "Attaching ${image} to a loop device"

	LOOPDEV=$(losetup --show --partscan --find "${image}")
	pr_debug "LOOPDEV: ${LOOPDEV}"
}

function losetup_detach()
{
	if [ -n "${LOOPDEV}" ] ; then
		return
	fi

	pr_info "Detaching image from ${LOOPDEV}"

	losetup --detach "${LOOPDEV}"
	LOOPDEV=
}

function mount_dev()
{
	local dev part

	pr_info "Mounting ${1}"

	IFS=':' read -r -a dev <<< "${1}"

	if [ -f "${dev[0]}" ] ; then
		# It's an image file, so attach it to a loop device
		losetup_attach "${dev[0]}"
		part=${LOOPDEV}p${dev[1]}
	else
		part=${dev[0]}${dev[1]}
	fi

	MOUNTPOINT=$(mktemp -d --tmpdir raspi-image-XXXXXX)
	mount "${part}" "${MOUNTPOINT}"
}

function umount_dev()
{
	if [ -z "${MOUNTPOINT}" ] ; then
		return
	fi

	pr_info "Unmounting ${MOUNTPOINT}"

	umount "${MOUNTPOINT}" || umount -l "${MOUNTPOINT}"
	rmdir "${MOUNTPOINT}"
	MOUNTPOINT=

	losetup_detach
}

function sfdisk_dev()
{
	local dev=${1} sfdisk_in=${2}

	# Exit if this is a dry-run
	if [ "${DRY_RUN}" -eq 1 ] ; then
		cat "${sfdisk_in}"
	fi
	dry_run_exit

	# Update the partition table
	if [ "${DEBUG}" -eq 1 ] ; then
		sfdisk "${dev}" < "${sfdisk_in}"
	else
		sfdisk -q "${dev}" < "${sfdisk_in}"
		sfdisk -l "${dev}"
	fi

	# Re-read the modified partition table
	if [ -b "${dev}" ] ; then
		partx -u "${dev}"
	fi
}

function build_uboot_scr()
{
	local script=${1}

	pr_info "Building u-boot script ${script}"

	mkimage -A arm -T script -C none -n 'u-boot script' -d "${script}" \
			"${script%.txt}"
}

# -----------------------------------------------------------------------------
# Main worker functions

function init_dev()
{
	local dev=${1} image=${2}
	local dev_size img_parts img_part1 img_part2
	local part1_start part1_size part1_type
	local part2_start part2_size part2_type

	pr_info "Initializing device ${dev}"

	# Get the size of the device (in #sectors)
	dev_size=$(sfdisk -s "${dev}")
	if [ -z "${dev_size}" ] ; then
		pr_error "Unable to get size of device ${dev}"
	fi
	dev_size=$((dev_size * 1024 / 512))
	pr_debug "dev_size: ${dev_size}"

	# Get the partition information from the image file
	readarray -t img_parts < <(probe_dev "${image}")
	IFS=' ' read -r -a img_part1 <<< "${img_parts[0]}"
	IFS=' ' read -r -a img_part2 <<< "${img_parts[1]}"
	pr_debug "img_part1: ${img_part1[*]}"
	pr_debug "img_part2: ${img_part2[*]}"

	# The (custom/multiboot) boot partition
	part1_start=2048
	part1_size=${img_part1[2]}
	part1_type=${img_part1[3]}
	pr_debug "part1: start ${part1_start}, size ${part1_size}," \
			 "type ${part1_type}"

	# The extended partition
	part2_start=$((part1_start + part1_size))
	part2_size=$((dev_size - part2_start))
	part2_type=5
	pr_debug "part2: start ${part2_start}, size ${part2_size}," \
			 "type ${part2_type}"

	# Create the input file for sfdisk
	cat <<EOF >sfdisk.in
label: dos
label-id: 0xdeadbeef
device: ${dev}
unit: sectors

${dev}1 : start=${part1_start}, size=${part1_size}, type=${part1_type}, bootable
${dev}2 : start=${part2_start}, size=${part2_size}, type=${part2_type}
EOF

	# Update the partition table
	sfdisk_dev "${dev}" sfdisk.in

	# Copy the boot partition from the Raspbian image
	dd_dev "${image}:1" "${dev}:1"

	# Configure the boot partition
	config_dev "${dev}:1"
}

function add_os()
{
	local dev=${1} image=${2}
	local dev_part img_parts img_part1 img_part2
	local part1_num part1_start part1_size part1_type
	local part2_num part2_start part2_size part2_type

	# Get the (last) partition information from the device
	IFS=' ' read -r -a dev_part <<< "$(probe_dev "${dev}" | tail -1)"
	pr_debug "dev_part: ${dev_part[*]}"

	# Get the partition information from the OS image
	readarray -t img_parts < <(probe_dev "${image}")
	IFS=' ' read -r -a img_part1 <<< "${img_parts[0]}"
	IFS=' ' read -r -a img_part2 <<< "${img_parts[1]}"
	pr_debug "img_part1: ${img_part1[*]}"
	pr_debug "img_part2: ${img_part2[*]}"

	# The new OS boot partition
	part1_num=$((dev_part[0] + 1))
	part1_start=$((dev_part[1] + dev_part[2]))
	part1_size=${img_part1[2]}
	part1_type=${img_part1[3]}

	# The new OS rootfs partition
	part2_num=$((part1_num + 1))
	part2_start=$((part1_start + part1_size))
	part2_size=$((4 * 1024 * 1024 * 1024 / 512))  # 4GB fixed size
	part2_type=${img_part2[3]}

	sfdisk -d "${dev}" > sfdisk.in
	cat <<EOF >> sfdisk.in
${dev}${part1_num} : start=${part1_start}, size=${part1_size}, type=${part1_type}
${dev}${part2_num} : start=${part2_start}, size=${part2_size}, type=${part2_type}
EOF

	# Update the partition table
	sfdisk_dev "${dev}" sfdisk.in

	# Copy the partitions from the OS image to the device
	dd_dev "${image}:1" "${dev}:${part1_num}"
	dd_dev "${image}:2" "${dev}:${part2_num}"
}

function config_dev()
{
	local dev boot boot_uuid rootfs rootfs_uuid num

	pr_info "Configuring device ${1}"

	IFS=':' read -r -a dev <<< "${1}"
	if [ ${#dev[@]} -eq 1 ] ; then
		dev[1]=1
	fi

	# The boot and rootfs partition numbers and UUIDs
	boot=${dev[1]}
	boot_uuid=$(printf "deadbeef-%02d" "${boot}")
	rootfs=$((boot + 1))
	rootfs_uuid=$(printf "deadbeef-%02d" "${rootfs}")

	if [ "${boot}" = "1" ] ; then
		# Configure the (custom/multiboot) boot partition
		mount_dev "${dev[0]}:1"
		pr_info "Configuring the boot partition"

		build_uboot_scr boot/boot.scr.txt
		cp boot/boot.scr boot/boot.scr.txt boot/config.txt boot/uboot_*.bin \
		   "${MOUNTPOINT}"/
		rm -f "${MOUNTPOINT}"/uboot_*.env "${MOUNTPOINT}"/*.img

		umount_dev

	else
		# Configure an OS rootfs partition
		mount_dev "${dev[0]}:${rootfs}"

		# Get the OS release information
		# shellcheck disable=SC1090
		.  "${MOUNTPOINT}"/etc/os-release
		pr_info "Configuring the '${PRETTY_NAME}' OS rootfs partition"

		if [ "${ID}" = "raspbian" ] ; then
			# Make sure nobody can call init_resize.sh since it would mess up
			# the partition table
			if [ -e "${MOUNTPOINT}"/usr/lib/raspi-config/init_resize.sh ] ; then
				mv "${MOUNTPOINT}"/usr/lib/raspi-config/init_resize.sh \
				   "${MOUNTPOINT}"/usr/lib/raspi-config/init_resize.sh.bak
			fi

			# Fix the UUIDs of the boot and rootfs partitions
			sed -i "s,PARTUUID=[0-9a-f]*-01,PARTUUID=${boot_uuid}," \
				"${MOUNTPOINT}"/etc/fstab
			sed -i "s,PARTUUID=[0-9a-f]*-02,PARTUUID=${rootfs_uuid}," \
				"${MOUNTPOINT}"/etc/fstab

		elif [ "${ID}" = "ubuntu" ] ; then
			# Make sure cloud-init doesn't run growpart since it would mess up
			# the partition table
			sed -i '/^ - growpart/d' "${MOUNTPOINT}"/etc/cloud/cloud.cfg

			# Fix the UUIDs of the boot and rootfs partitions
			sed -i "s,LABEL=system-boot,PARTUUID=${boot_uuid}," \
				"${MOUNTPOINT}"/etc/fstab
			sed -i "s,LABEL=cloudimg-rootfs,PARTUUID=${rootfs_uuid}," \
				"${MOUNTPOINT}"/etc/fstab

		else
			pr_info "Unknown OS ID ${ID}"
		fi

		umount_dev

		# Configure the OS boot partition
		mount_dev "${dev[0]}:${boot}"
		pr_info "Configuring the '${PRETTY_NAME}' OS boot partition"

		sed -e "s,__BOOT__,${boot}," \
			-e "s,__ROOTFS_UUID__,${rootfs_uuid}," \
			boot/"${ID}"/boot.scr.txt > "${MOUNTPOINT}"/boot.scr.txt
		build_uboot_scr  "${MOUNTPOINT}"/boot.scr.txt

		umount_dev

		# Add the OS to the multiboot menu
		mount_dev "${dev[0]}:1"
		pr_info "Adding '${PRETTY_NAME}' to the multiboot menu"

		num=$((((boot - 5)) / 2))
		sed -i "s,^.*setenv x_title${num}.*,setenv x_title${num} \"${PRETTY_NAME}\"," \
			"${MOUNTPOINT}"/boot.scr.txt
		build_uboot_scr "${MOUNTPOINT}"/boot.scr.txt

		umount_dev
	fi
}

function dd_dev()
{
	local src dst dd_opts src_part dst_part

	pr_info "Copying device/partition ${1} to ${2}"

	IFS=':' read -r -a src <<< "${1}"
	IFS=':' read -r -a dst <<< "${2}"

	src_part=()
	dst_part=()
	dd_opts=("if=${src[0]}" "of=${dst[0]}" "bs=512" "conv=notrunc")

	pr_debug "src: ${src[*]}"
	if [ "${#src[@]}" -eq 2 ] ; then
		# Source partition number specified, get the partition details
		IFS=' ' read -r -a src_part < <(probe_dev "${src[0]}" | \
											grep "^${src[1]} ")
		pr_debug "src_part: ${src_part[*]}"
		dd_opts+=("skip=${src_part[1]}" "count=${src_part[2]}")
	fi

	pr_debug "dst: ${dst[*]}"
	if [ "${#dst[@]}" -eq 2 ] ; then
		# Destination partition number specified, get the partition details
		IFS=' ' read -r -a dst_part < <(probe_dev "${dst[0]}" | \
											grep "^${dst[1]} ")
		pr_debug "dst_part: ${dst_part[*]}"
		dd_opts+=("seek=${dst_part[1]}")
	fi

	pr_debug "dd_opts: ${dd_opts[*]}"

	# Check that the destination partition is big enough
	if [ "${#src_part[@]}" -gt 1 ] && [ "${#dst_part[@]}" -gt 1 ] && \
		   [ "${src_part[2]}" -gt "${dst_part[2]}" ] ; then
		pr_error "Destination partition is too small"
	fi

	# Exit if this is a dry-run
	dry_run_exit

	# Copy the partition
	dd "${dd_opts[@]}"
}

# -----------------------------------------------------------------------------
# Commands

function do_init()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	init_dev "${@}"
}

function do_add()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	add_os "${@}"
}

function do_config()
{
	if [ $# -ne 1 ] ; then
		usage
		exit 2
	fi

	config_dev "${@}"
}

function do_dd()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	dd_dev "${@}"
}

function usage()
{
	trap - EXIT INT TERM HUP

	cat <<EOF
Usage: raspi-image [-d] [-h] [r] COMMAND [OPTIONS]

Supported commands
  init DEVICE RASPBIAN_IMAGE
                 Initialize the device DEVICE using the Raspbian image
                 RASPBIAN_IMAGE.
  add DEVICE OS_IMAGE
                 Add the OS from OS_IMAGE to the device DEVICE.
  config DEVICE[:PARTITION]
                 Configure partition PARTITION of device DEVICE. If not
                 specified, PARTITION defaults to 1.
  dd DEVICE1[:PARTITION1] DEVICE2[:PARTITION2]
                 Copy DEVICE1 to DEVICE2 using 'dd'. Operate on a partition
                 rather than a whole device if a PARTITIION number is
                 specified.

Positional arguments:
  -d, --debug    Enable debugging output.
  -h, --help     Show this help text and exit.
  -r, --dry-run  Dry run mode. If specified, no modifcations of a device/image
                 are made.
EOF
}

DEBUG=0
DRY_RUN=0
cmd=
cmd_opts=()

while [ $# -gt 0 ] ; do
	case "${1}" in
		-d|--debug)
			DEBUG=1
			;;
		-h|--help)
			usage
			exit
			;;
		-r|--dry-run)
			DRY_RUN=1
			;;
		-*)
			pr_error "Unexpected argument: ${1}"
			;;
		*)
			cmd=${1}
			shift
			cmd_opts=("${@}")
			break
	esac
	shift
done

case "${cmd}" in
	init|config|add|dd)
		true
		;;
	*)
		usage
		exit 2
		;;
esac

MOUNTPOINT=
LOOPDEV=
trap out EXIT INT TERM HUP

"do_${cmd}" "${cmd_opts[@]}"
