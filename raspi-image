#!/bin/bash -eu
#
# Build and manipulate a Raspberry Pi image
#

function out()
{
	local rc=${?}

	trap - INT TERM EXIT HUP

	if [ -n "${MOUNTDEV}" ] && [ -n "${MOUNTPOINT}" ] ; then
		# Unmount any device that's still mounted
		umount_dev "${MOUNTDEV}" "${MOUNTPOINT}"
		rmdir "${MOUNTPOINT}"
	fi

	if [ "${rc}" -ne 0 ] ; then
		# Emit a message if the script failed
		pr_error "Script failed"
	fi

	exit "${rc}"
}

function dry_run_exit()
{
	if [ "${DRY_RUN}" -eq 1 ] ; then
		pr_info "Dry-run, exiting..."
		exit
	fi
}

function pr_info()
{
    echo -e "\033[33m${*}\033[0m"

}

function pr_debug()
{
    [ "${DEBUG}" -eq 0 ] || echo -e "\033[36m${*}\033[0m"

}

function pr_error()
{
    echo -e "\033[31mError: ${*}\033[0m" >&2
	exit 1

}

function align()
{
	local val=${1} align=${2}

	echo $(($((val / align + 1)) * align))
}

function probe_dev()
{
	local dev=${1}
	local nr start size ptype

	while IFS=' ' read -r nr start size ptype ; do
		echo "${nr} ${start} ${size} ${ptype#0x}"
	done < <(partx -g -o NR,START,SECTORS,TYPE "${dev}")
}

function partx_add_dev()
{
	local dev

	IFS=':' read -r -a dev <<< "${1}"

	# Add the specified partition and print the loop device /dev/loopX
	partx -v -a -n "${dev[1]}" "${dev[0]}" | \
		grep "partition #${dev[1]} added" | sed 's,:.*,,'
}

function partx_del_dev()
{
	local dev

	IFS=':' read -r -a dev <<< "${1}"

	# Delete the specified partition
	partx -v -d -n "${dev[1]}" "${dev[0]}"
}

function mount_dev()
{
	local dev mountpoint loopdev part

	pr_info "Mounting ${1}"

	IFS=':' read -r -a dev <<< "${1}"
	mountpoint=${2}

	if [ -f "${dev[0]}" ] ; then
		# It's an image file, so run partx -a (add)
		pr_info "Adding partition ${1}"
		loopdev=$(partx_add_dev "${1}")
		pr_debug "loopdev: ${loopdev}"
		part=${loopdev}p${dev[1]}
	else
		part=${dev[0]}${dev[1]}
	fi

	mount "${part}" "${mountpoint}"
}

function umount_dev()
{
	local dev mountpoint

	pr_info "Unmounting ${1}"

	IFS=':' read -r -a dev <<< "${1}"
	mountpoint=${2}

	umount "${mountpoint}" || umount -l "${mountpoint}"

	if [ -f "${dev[0]}" ] ; then
		pr_info "Deleting partition ${1}"
		# It's a image file, so run partx -d (delete)
		partx_del_dev "${1}"
	fi
}

function sfdisk_dev()
{
	local dev=${1} sfdisk_in=${2}

	# Exit if this is a dry-run
	if [ "${DRY_RUN}" -eq 1 ] ; then
		cat "${sfdisk_in}"
	fi
	dry_run_exit

	# Update the partition table
	if [ "${DEBUG}" -eq 1 ] ; then
		sfdisk "${dev}" < "${sfdisk_in}"
	else
		sfdisk -q "${dev}" < "${sfdisk_in}"
		sfdisk -l "${dev}"
	fi

	# Re-read the modified partition table
	if [ -b "${dev}" ] ; then
		partx -u "${dev}"
	fi
}

function build_uboot_scr()
{
	local script=${1}

	pr_info "Building u-boot script ${script}"

	mkimage -A arm -T script -C none -n 'u-boot script' -d "${script}" \
			"${script%.txt}"
}

# -----------------------------------------------------------------------------
# Main worker functions

function init_dev()
{
	local dev=${1} image=${2}
	local dev_size img_parts img_part1 img_part2
	local part1_start part1_size part1_type
	local part2_start part2_size part2_type

	pr_info "Initializing device ${dev}"

	# Get the size of the device (in #sectors)
	dev_size=$(sfdisk -s "${dev}")
	if [ -z "${dev_size}" ] ; then
		pr_error "Unable to get size of device ${dev}"
	fi
	dev_size=$((dev_size * 1024 / 512))
	pr_debug "dev_size: ${dev_size}"

	# Get the partition information from the image file
	readarray -t img_parts < <(probe_dev "${image}")
	IFS=' ' read -r -a img_part1 <<< "${img_parts[0]}"
	IFS=' ' read -r -a img_part2 <<< "${img_parts[1]}"
	pr_debug "img_part1: ${img_part1[*]}"
	pr_debug "img_part2: ${img_part2[*]}"

	# The (custom/multiboot) boot partition
	part1_start=2048
	part1_size=${img_part1[2]}
	part1_type=${img_part1[3]}
	pr_debug "part1: start ${part1_start}, size ${part1_size}," \
			 "type ${part1_type}"

	# The extended partition
	part2_start=$((part1_start + part1_size))
	part2_size=$((dev_size - part2_start))
	part2_type=5
	pr_debug "part2: start ${part2_start}, size ${part2_size}," \
			 "type ${part2_type}"

	# Create the input file for sfdisk
	cat <<EOF >sfdisk.in
label: dos
label-id: 0xdeadbeef
device: ${dev}
unit: sectors

${dev}1 : start=${part1_start}, size=${part1_size}, type=${part1_type}, bootable
${dev}2 : start=${part2_start}, size=${part2_size}, type=${part2_type}
EOF

	# Update the partition table
	sfdisk_dev "${dev}" sfdisk.in

	# Copy the boot partition from the Raspbian image
	dd_dev "${image}:1" "${dev}:1"

	# Configure the boot partition
	config_dev "${dev}:1"
}

function add_os()
{
	local dev=${1} image=${2}
	local dev_part img_parts img_part1 img_part2
	local part1_num part1_start part1_size part1_type
	local part2_num part2_start part2_size part2_type

	# Get the (last) partition information from the device
	IFS=' ' read -r -a dev_part <<< "$(probe_dev "${dev}" | tail -1)"
	pr_debug "dev_part: ${dev_part[*]}"

	# Get the partition information from the OS image
	readarray -t img_parts < <(probe_dev "${image}")
	IFS=' ' read -r -a img_part1 <<< "${img_parts[0]}"
	IFS=' ' read -r -a img_part2 <<< "${img_parts[1]}"
	pr_debug "img_part1: ${img_part1[*]}"
	pr_debug "img_part2: ${img_part2[*]}"

	# The new OS boot partition
	part1_num=$((dev_part[0] + 1))
	part1_start=$((dev_part[1] + dev_part[2]))
	part1_size=${img_part1[2]}
	part1_type=${img_part1[3]}

	# The new OS rootfs partition
	part2_num=$((part1_num + 1))
	part2_start=$((part1_start + part1_size))
	part2_size=$((4 * 1024 * 1024 * 1024 / 512))  # 4GB fixed size
	part2_type=${img_part2[3]}

	sfdisk -d "${dev}" > sfdisk.in
	cat <<EOF >> sfdisk.in
${dev}${part1_num} : start=${part1_start}, size=${part1_size}, type=${part1_type}
${dev}${part2_num} : start=${part2_start}, size=${part2_size}, type=${part2_type}
EOF

	# Update the partition table
	sfdisk_dev "${dev}" sfdisk.in

	# Copy the partitions from the OS image to the device
	dd_dev "${image}:1" "${dev}:${part1_num}"
	dd_dev "${image}:2" "${dev}:${part2_num}"
}

function config_dev()
{
	local dev num

	pr_info "Configuring device ${1}"

	IFS=':' read -r -a dev <<< "${1}"
	if [ ${#dev[@]} -eq 1 ] ; then
		dev[1]=1
	fi

	# Create a temporary mount point
	MOUNTPOINT=$(mktemp -d --tmpdir raspi-image-XXXXXX)
	pr_debug "MOUNTPOINT: ${MOUNTPOINT}"

	if [ "${dev[1]}" = "1" ] ; then
		# Configure the (custom/multiboot) boot partition
		MOUNTDEV=${dev[0]}:1
		pr_debug "MOUNTDEV: ${MOUNTDEV}"
		mount_dev "${MOUNTDEV}" "${MOUNTPOINT}"
		pr_info "Configuring the boot partition ${MOUNTDEV}"

		build_uboot_scr boot/boot.scr.txt
		cp boot/boot.scr boot/boot.scr.txt boot/config.txt boot/uboot_*.bin \
		   "${MOUNTPOINT}"/
		rm -f "${MOUNTPOINT}"/uboot_*.env "${MOUNTPOINT}"/*.img

		umount_dev "${MOUNTDEV}" "${MOUNTPOINT}"

	else
		# Configure an OS rootfs partition
		MOUNTDEV=${dev[0]}:$((dev[1] + 1))
		pr_debug "MOUNTDEV: ${MOUNTDEV}"
		mount_dev "${MOUNTDEV}" "${MOUNTPOINT}"

		# Get the OS release information
		# shellcheck disable=SC1090
		.  "${MOUNTPOINT}"/etc/os-release
		pr_info "Configuring the '${PRETTY_NAME}' OS rootfs partition ${MOUNTDEV}"

		# Make sure nobody can call init_resize.sh since it would mess up our
		# partition table
		if [ -e "${MOUNTPOINT}"/usr/lib/raspi-config/init_resize.sh ] ; then
			mv "${MOUNTPOINT}"/usr/lib/raspi-config/init_resize.sh \
			   "${MOUNTPOINT}"/usr/lib/raspi-config/init_resize.sh.bak
		fi

		# Fix the UUIDs of the boot and rootfs partitions
		sed -i 's,PARTUUID=[0-9a-f]*-01,PARTUUID=deadbeef-05,' \
			"${MOUNTPOINT}"/etc/fstab
		sed -i 's,PARTUUID=[0-9a-f]*-02,PARTUUID=deadbeef-06,' \
			"${MOUNTPOINT}"/etc/fstab

		umount_dev "${MOUNTDEV}" "${MOUNTPOINT}"

		# Configure the OS boot partition
		MOUNTDEV=${dev[0]}:${dev[1]}
		pr_debug "MOUNTDEV: ${MOUNTDEV}"
		mount_dev "${MOUNTDEV}" "${MOUNTPOINT}"
		pr_info "Configuring the '${PRETTY_NAME}' OS boot partition ${MOUNTDEV}"

		build_uboot_scr boot/"${ID}"/boot.scr.txt
		cp boot/"${ID}"/boot.scr "${MOUNTPOINT}"/

		umount_dev "${MOUNTDEV}" "${MOUNTPOINT}"

		# Add the OS to the multiboot menu
		MOUNTDEV=${dev[0]}:1
		pr_debug "MOUNTDEV: ${MOUNTDEV}"
		mount_dev "${MOUNTDEV}" "${MOUNTPOINT}"
		pr_info "Adding '${PRETTY_NAME}' to the multiboot menu"

		num=$((((dev[1] - 5)) / 2))
		sed -i "s,^.*setenv x_title${num}.*,setenv x_title${num} \"${PRETTY_NAME}\","  "${MOUNTPOINT}"/boot.scr.txt
		build_uboot_scr "${MOUNTPOINT}"/boot.scr.txt

		umount_dev "${MOUNTDEV}" "${MOUNTPOINT}"
	fi

	# Cleanup
	rmdir "${MOUNTPOINT}" || true
	MOUNTDEV=
	MOUNTPOINT=
}

function dd_dev()
{
	local src dst dd_opts src_part dst_part

	pr_info "Copying device/partition ${1} to ${2}"

	IFS=':' read -r -a src <<< "${1}"
	IFS=':' read -r -a dst <<< "${2}"

	src_part=()
	dst_part=()
	dd_opts=("if=${src[0]}" "of=${dst[0]}" "bs=512" "conv=notrunc")

	pr_debug "src: ${src[*]}"
	if [ "${#src[@]}" -eq 2 ] ; then
		# Source partition number specified, get the partition details
		IFS=' ' read -r -a src_part < <(probe_dev "${src[0]}" | \
											grep "^${src[1]} ")
		pr_debug "src_part: ${src_part[*]}"
		dd_opts+=("skip=${src_part[1]}" "count=${src_part[2]}")
	fi

	pr_debug "dst: ${dst[*]}"
	if [ "${#dst[@]}" -eq 2 ] ; then
		# Destination partition number specified, get the partition details
		IFS=' ' read -r -a dst_part < <(probe_dev "${dst[0]}" | \
											grep "^${dst[1]} ")
		pr_debug "dst_part: ${dst_part[*]}"
		dd_opts+=("seek=${dst_part[1]}")
	fi

	pr_debug "dd_opts: ${dd_opts[*]}"

	# Check that the destination partition is big enough
	if [ "${#src_part[@]}" -gt 1 ] && [ "${#dst_part[@]}" -gt 1 ] && \
		   [ "${src_part[2]}" -gt "${dst_part[2]}" ] ; then
		pr_error "Destination partition is too small"
	fi

	# Exit if this is a dry-run
	dry_run_exit

	# Copy the partition
	dd "${dd_opts[@]}"
}

# -----------------------------------------------------------------------------
# Commands

function do_init()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	init_dev "${@}"
}

function do_add()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	add_os "${@}"
}

function do_config()
{
	if [ $# -ne 1 ] ; then
		usage
		exit 2
	fi

	config_dev "${@}"
}

function do_dd()
{
	if [ $# -ne 2 ] ; then
		usage
		exit 2
	fi

	dd_dev "${@}"
}

function usage()
{
	trap - EXIT INT TERM HUP

	cat <<EOF
Usage: raspi-image [-d] [-h] [r] COMMAND [OPTIONS]

Supported commands
  init DEVICE RASPBIAN_IMAGE
                 Initialize the device DEVICE using the Raspbian image
                 RASPBIAN_IMAGE.
  add DEVICE OS_IMAGE
                 Add the OS from OS_IMAGE to the device DEVICE.
  config DEVICE[:PARTITION]
                 Configure partition PARTITION of device DEVICE. If not
                 specified, PARTITION defaults to 1.
  dd DEVICE1[:PARTITION1] DEVICE2[:PARTITION2]
                 Copy DEVICE1 to DEVICE2 using 'dd'. Operate on a partition
                 rather than a whole device if a PARTITIION number is
                 specified.

Positional arguments:
  -d, --debug    Enable debugging output.
  -h, --help     Show this help text and exit.
  -r, --dry-run  Dry run mode. If specified, no modifcations of a device/image
                 are made.
EOF
}

DEBUG=0
DRY_RUN=0
cmd=
cmd_opts=()

while [ $# -gt 0 ] ; do
	case "${1}" in
		-d|--debug)
			DEBUG=1
			;;
		-h|--help)
			usage
			exit
			;;
		-r|--dry-run)
			DRY_RUN=1
			;;
		-*)
			pr_error "Unexpected argument: ${1}"
			;;
		*)
			cmd=${1}
			shift
			cmd_opts=("${@}")
			break
	esac
	shift
done

case "${cmd}" in
	init|config|add|dd)
		true
		;;
	*)
		usage
		exit 2
		;;
esac

MOUNTDEV=
MOUNTPOINT=
trap out EXIT INT TERM HUP

"do_${cmd}" "${cmd_opts[@]}"
